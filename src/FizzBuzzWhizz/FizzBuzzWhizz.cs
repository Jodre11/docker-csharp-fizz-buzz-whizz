namespace FizzBuzzWhizz;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class FizzBuzzWhizz : IIncrementalGenerator
{
    private const string Namespace = "FizzBuzzWhizz";
    private const string AttributeName = "FizzBuzzWhizzAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>
namespace {Namespace};

[System.AttributeUsage(System.AttributeTargets.Class)]
public class {AttributeName} : System.Attribute
{{
    private {AttributeName}()
    {{
    }}

    /// <summary>
    /// An attribute to mark a partial class for processing by the {Namespace} engine.
    /// </summary>
    /// <param name=""rules"">
    /// A sequence of strings denoting one or many pairs.
    /// Every odd item must be a string value, every even item parsable to a long
    /// e.g. <c>[""Fizz"", ""3"", ""Buzz"", ""5""]</c>.
    /// </param>
    /// <exception cref=""System.ArgumentNullException""></exception>
    /// <exception cref=""System.ArgumentException""></exception>
    public {AttributeName}(params string[] rules)
    {{
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.Rules is not null)
            .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right!));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the attribute and maps syntax context to the specific node type
    /// (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and the rules from the attribute if found.</returns>
    private static (ClassDeclarationSyntax Declaration, KeyValuePair<long, string>[]? Rules)
        GetClassDeclarationForSourceGen(
            GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var rules = GetRulesFromAttributes(classDeclarationSyntax, context.SemanticModel);
        return (classDeclarationSyntax, rules);
    }

    private static KeyValuePair<long, string>[]? GetRulesFromAttributes(
        ClassDeclarationSyntax classDeclarationSyntax, SemanticModel semanticModel)
    {
        foreach (var attributeSyntax in classDeclarationSyntax.AttributeLists
                     .SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            if (!IsFizzBuzzWhizzAttribute(attributeSyntax, semanticModel))
                continue;

            if (attributeSyntax.ArgumentList?.Arguments is not { Count: > 1 } arguments)
                continue;

            var rules = ParseRules(arguments);
            if (rules.Length > 0)
                return rules;
        }

        return null;
    }

    private static bool IsFizzBuzzWhizzAttribute(AttributeSyntax attributeSyntax, SemanticModel semanticModel)
    {
        var symbol = semanticModel.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;
        return symbol?.ContainingType.ToDisplayString() == $"{Namespace}.{AttributeName}";
    }

    private static KeyValuePair<long, string>[] ParseRules(SeparatedSyntaxList<AttributeArgumentSyntax> arguments)
    {
        var pairCount = arguments.Count / 2;
        var rules = new List<KeyValuePair<long, StringBuilder>>(pairCount);
        var rulesLookup = new Dictionary<long, KeyValuePair<long, StringBuilder>>(pairCount);
        for (var i = 0; i < pairCount * 2; i += 2)
        {
            if (arguments[i].Expression is not LiteralExpressionSyntax substituteLiteral ||
                !substituteLiteral.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringLiteralExpression) ||
                arguments[i + 1].Expression is not LiteralExpressionSyntax numberLiteral ||
                !numberLiteral.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringLiteralExpression))
            {
                continue;
            }

            var substitute = substituteLiteral.Token.ValueText;
            var divisorString = numberLiteral.Token.ValueText;
            if (!long.TryParse(divisorString, out var divisor)) continue;

            if (rulesLookup.ContainsKey(divisor))
            {
                // If the same number is already present, append the new substitute to the existing one.
                rulesLookup[divisor].Value.Append(substitute);
            }
            else
            {
                // Otherwise, create a new entry.
                var newRule = new KeyValuePair<long, StringBuilder>(divisor, new StringBuilder(substitute));
                rules.Add(newRule);
                rulesLookup[divisor] = newRule;
            }
        }

        return rules
            .Select(p => new KeyValuePair<long, string>(p.Key, p.Value.ToString()))
            .ToArray();
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes
    /// (ClassDeclarationSyntax annotated with the correctly configured attribute)
    /// changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="sites">Partial classes where an appropriately configured attribute is applied.</param>
    private void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<(ClassDeclarationSyntax Declaration, KeyValuePair<long, string>[] Rules)> sites)
    {
        // Go through all filtered class declarations.
        foreach (var (declaration, rules) in sites)
        {
            // We need to get a semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(declaration.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(declaration) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get a class name from the syntax node.
            var className = declaration.Identifier.Text;

            var identityMethodBody = GenerateIdentityBody(rules);

            // Build up the source code
            var code = $@"// <auto-generated/>
namespace {namespaceName};

partial class {className}
{{
    public string Identity(long n)
    {{
        if (n == 0) return ""0"";
{string.Join("\n", identityMethodBody)}
        return n.ToString();
    }}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    /// <summary>
    /// Generates the body of the Identity method with performance optimization for large rule sets.
    /// </summary>
    private IEnumerable<string> GenerateIdentityBody(KeyValuePair<long, string>[] rules)
    {
        // Use exponential approach for small rule sets (optimal performance)
        if (rules.Length <= 6)
        {
            return GenerateExponentialApproach(rules);
        }

        // Use linear approach for larger rule sets (prevents exponential blowup)
        return GenerateLinearApproach(rules);
    }

    /// <summary>
    /// Original exponential approach - optimal for small rule sets.
    /// </summary>
    private IEnumerable<string> GenerateExponentialApproach(KeyValuePair<long, string>[] rules)
    {
        var moduloExpressions = rules
            .Select(rule => $"n % {rule.Key} == 0")
            .ToArray();

        foreach (var perm in GetBooleanPermutations(rules.Length))
        {
            var expressionsToInclude = perm
                .Zip(
                    moduloExpressions,
                    (include, moduloExpression) => (include, moduloExpression))
                .Where(expression => expression.include)
                .Select(expression => expression.moduloExpression);

            var valuesToInclude = perm
                .Zip(
                    rules,
                    (include, rule) => (include, rule.Value))
                .Where(value => value.include)
                .Select(value => value.Value);

            var expression = string.Join(" && ", expressionsToInclude);
            var substitutes = string.Concat(valuesToInclude);
            yield return $"        if ({expression}) return \"{substitutes}\";";
        }
    }

    /// <summary>
    /// Linear approach - builds result incrementally, O(n) complexity.
    /// </summary>
    private IEnumerable<string> GenerateLinearApproach(KeyValuePair<long, string>[] rules)
    {
        yield return "        var result = new System.Text.StringBuilder();";
        yield return "        bool hasMatch = false;";

        foreach (var rule in rules)
        {
            yield return $"        if (n % {rule.Key} == 0)";
            yield return "        {";
            yield return $"            result.Append(\"{rule.Value}\");";
            yield return "            hasMatch = true;";
            yield return "        }";
        }

        yield return "        if (hasMatch) return result.ToString();";
    }

    private static IEnumerable<bool[]> GetBooleanPermutations(int n)
    {
        // Iterate over all possible bitmasks except all-false (0)
        var total = 1 << n;
        var masks = Enumerable.Range(1, total - 1)
            .OrderByDescending(CountBits)
            .ThenBy(mask => mask);

        foreach (var mask in masks)
        {
            var arr = new bool[n];
            for (int i = 0; i < n; i++)
                arr[i] = (mask & (1 << (n - i - 1))) != 0;
            yield return arr;
        }

        static int CountBits(int x)
        {
            int count = 0;
            while (x != 0)
            {
                count += x & 1;
                x >>= 1;
            }

            return count;
        }
    }
}
